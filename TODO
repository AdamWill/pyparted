- autoconf/automake the entire tree
      'make install' and make sure Python modules are installed correctly

- use disttools from Python to do as much work as possible

- new native Python classes on top of _ped (going to require a bit of
  thought to figure out what sort of API we want for the 'parted' module,
  the following are just ideas):
      Device
      Disk
      Partition
      Filesystem
      Constraint
      Label

- Walk through all of the src/py*.c files and make sure libparted exceptions
  are captured and filtered back up through Python.  Will need to define some
  sane Python exception classes for libparted's exceptions.

- Handle exceptions from libparted and pass to Python as necessary.  The
  PED_ASSERT things are where libparted aborts, so we may want to catch things
  before it goes in to libparted so we can throw an exception rather than
  letting the library abort().  The ped_exception_throw() instances are all
  libparted's own exception-like system.

- Handle exceptions throughout the _ped module code.  Unique exceptions as
  much as possible.

- Rename modules under _ped to use all lowercase names.  Make sure all classes
  are named with studly caps (e.g., BigGiantWorthlessClass)

- Figure out what, if anything, we can do with timers.  They are optional in
  libparted, but do we want to support them in pyparted?

- Error handling in the get and set methods.

- Free memory in error handling cases.

- Exception handling:
      - Audit error messages to make them more useful.

- Test cases:
    _ped.Constraint
    _ped.Device
    _ped.Disk
    _ped.DiskType
    _ped.FileSystem
    _ped.FileSystemType
    _ped.Partition
    _ped.Timer
    _ped.constraint_new_from_min_max
    _ped.constraint_new_from_min
    _ped.constraint_new_from_max
    _ped.constraint_any
    _ped.constraint_exact
    _ped.device_get_next
    _ped.file_system_probe
    _ped.file_system_probe_specific
    _ped.unit_format_custom_byte
    _ped.unit_format_byte
    _ped.unit_format_custom
    _ped.unit_format
    _ped.unit_get_size
    _ped.unit_parse
    _ped.unit_parse_custom
    _ped.probe_all_devices
    _ped.free_all_devices
    _ped.flag_get_next

- Make sure PyTypeObjects that have a tp_init are allocating memory that the
  garbage collector knows about.  I'm not sure if PyType_GenericAlloc or
  PyType_GenericNew do this.

- Coding policy that we need to make sure we're doing:
  If object creation fails, we need to use PyObject_GC_Del() to destroy it
  before throwing an exception at the user.  For all other instances where
  we need to delete or destroy the object, use Py_XDECREF().  Once the ref
  count is zero, the GC will take over and run dealloc() for that object,
  which will eventually run PyObject_GC_Del().  Basically, we should only
  be using PyObject_GC_Del() in the convert functions or in __init__
  constructors where we are making a new object for the user.

  NOTE: If we need to destroy an object due to creation failure and the
  object we are creating has other PyObject members, call Py_XDECREF on
  those members rather than destroing them.  We can't ensure that there
  will be no other references to those members, so let the normal object
  destructor handle PyObject members, but forcefully destroy the object
  we are trying to create.

- destroy() methods don't seem to be destroying the Python object.

- Make sure this new code works in Python 3000

- Look through all PyTypeObject objects and see where we can expand
  their functionality.  Can we add str() support, for instance.

- Move the constraint functions presently in _ped to be in the __init_()
  method for _ped.Constraint, similar to what was done for _ped_Disk_init:
      constraint_new_from_min_max
      constraint_new_from_min
      constraint_new_from_max
      constraint_any
      constraint_exact

- The git repository has a missing ref in it and it causes git-fetch to
  choke all the time.  Figure out how to remove this from the git repo.
      error: unable to find 09467a8feaa343e6ea79bdeebf3c70834d28941c
      fatal: object 09467a8feaa343e6ea79bdeebf3c70834d28941c not found

- Audit libparted code and make a list of all properties that should be
  read-only and make them such in the _ped and parted code.  Right now,
  everything is rw, but libparted doesn't permit that for everything.  We
  need to enforce that at the parted and _ped levels.

- parted module:
      - Create getPed_____() methods to return the low-level _ped type
        contained within the high-level object.
      - Let __init__ methods for each class accept either a low-level
        _ped type or all of the high-level parted objects that could be
        used to create the _ped type.
      - Write docstrings for everything
      - Sort out the __all__/import/from mess so that we can rely on
        'import parted' and get correct namespace

... and much much more
